## JPA Relationship of Entities - ManyToOne & OneToMany

출처 : 자바 ORM 표준 JPA 프로그래밍 (저자 : **김영한**)

"엔티티들은 대부분 다른 엔티티와 연관관계를 맺는다. 예를 들어 주문 엔티티는 어떤 상품을 주문했는 지 알기 위해 상품 엔티티와 연관관계를 맺고 상품 엔티티는 카테고리, 재고 등 또 다른 엔티티와 관계가 있다. **그런데 객체는 참조(주소)를 사용해서 관계를 맺고 테이블은 외래 키를 사용해서 관계를 맺는다.** 이 둘은 완전히 다른 특징을 가진다. **객체 관계 매핑(ORM)에서 가장 어려운 부분이 바로 객체 연관관계와 테이블 연과관계를 매핑하는 일이다.**"

JPA 엔티티 간 연관관계를 맺는 것은 결국 객체의 참조와 테이블의 외래 키를 매핑하는 것이다. 연관관계 매핑을 이해하기 위한 핵심 키워드는 다음과 같다. 

- **Direction** : 

  두 엔티티 간 관계가 있을 때 한 쪽만 참조하는 것을 단방향, 양쪽 모두 서로 참조하는 것을 양방향 관계라 한다. **방향은 객체 관계에서만 존재하고, 테이블 관계는 항상 양방향이다.** (사실 이 부분을 읽고 나서야 객체 관계에서의 단방향 관계 정의를 받아들인 것 같다. 직관적으로 객체의 단방향성이 이해가 되지 않았었다.)

- **Multiplicity** :

  다대일, 일대다, 일대일, 다대다 다중성이 있다. 

- **Owner** :

  **객체**를 양방향 연관관계로 만들면 **연관관계의 주인을 정해야 한다.**

____

### 단방향 연관관계 (Uni-Directional) via 회원 : 팀 (다대일 연관관계) 

- 회원과 팀이 있다. 
- 회원은 하나의 팀에만 소속될 수 있다.
- 회원과 팀은 다대일 관계이다. (= <u>여러</u> 회원이 <u>하나의</u> 팀에 소속된다. )



**객체 연관관계** 

- A 회원이 __팀에 소속된 지 알 수 있다. (회원 ---> 팀)
- __팀에 소속된 팀원(들)은 알 수 없다. (팀 ---> 회원 **X**)



**테이블 연관관계** 

- 객체 연관관계와 달리, 양방향 관계로 **Join**을 통해서 A 유저가 소속된 팀과 팀에 소속된 팀원(들)을 모두 알 수 있다.



**객체 연관관계 vs 테이블 연관관계 on 양방향 연관관계** 

**객체를 양방향으로 참조하기 위해서는 단방향 연관관계를 2개 만들어야 한다. 이는 즉, 각각의 엔티티에 참조할 수 있는 필드를 서로 가져야 한다는 것이다.** 

___

**JPA를 사용해서 객체 연관관계와 테이블 연관관계의 관계를 매핑해보자** 

```java
@Entity
public class Member {
  
  @Id
  @Column(name = "MEMBER_ID")
  private String id; 
  
  private String usernmae;
  
  // 연관관계 매핑 
  // 객체 연관관계 상에서 Team 필드를 가진다. 
  @ManyToOne
  @JoinColumn(name="TEAM_ID")
  private Team team;
  
  // 연관관계 설정
  public void setTeam(Team team) {
    this.team = team;
  }
}

@Entity
public class Team {
  
  @Id
  @Column(name = "TEAM_ID")
  private String id;
  
  private String name; 
 
}

결국 "Member.team과 Member.TEAM_ID를 매핑하는 것이 연관관계 매핑이다." @JoinColumn은 외래 키를 매핑할 때 사용한다. name 속성에는 매핑할 외래 키 이름을 지정한다. (생략 가능한 어노테이션)

@JoinColumn을 생략하면, 외래 키를 찾을 때 기본 전략을 사용하는데, 
기본 전략 : 필드명 + _ + 참조하는 테이블의 컬럼명 
위 케이스의 경우 team_TEAM_ID
```

____

**연관관계 사용 (저장, 조회, 수정, 삭제)**



***조회*** : 

객체 그래프 탐색 (객체 연관관계를 사용한 조회)

객체지향 쿼리 사용 (JPQL)

***수정*** : 

EntityManager에는 update() 같은 메소드가 없다. 단순히 불러온 엔티티의 값만 변경해두면, 트랜잭션을 커밋할 때 플러시가 일어나면서 변경 감지 기능이 작동한다. 그리고 변경 사항을 데이터베이스에 자동으로 반영한다. 이것은 연관관계를 수정할 때도 같은데, 참조하는 대상만 변경하면 나머지는 JPA가 자동으로 처리한다. 

***제거 및 삭제*** :

연관된 엔티티를 삭제하려면 기존에 있던 연관관계를 먼저 제거하고 삭제해야 한다. 그렇지 않으면 외래 키 제약조건으로 인해 데이터베이스에서 오류가 발생한다.

_____

### 양방향 연관관계 (Bi-Directional) via 회원 : 팀 

객체 연관관계에서는 양방향 관계를 맺기 위해 기존에 팀 필드에 없던 '회원(s)' 필드를 추가해야 한다. 이 때 Collection, Set, Map 같은 다양한 컬렉션을 지원한다. 반면, 앞서 언급한 것과 같이 테이블 연관관계에서는 따로 추가할 부분이 없다 (이미 양방향 관계 via Join Clause)

```java
@Entity
public class Team {
  
  @Id
  @Column(name = "TEAM_ID")
  private String id;
  
  private String name; 
  
  // 추가 // 
  @OneToMany(mappeBy = "team")
  private List<Member> members = new ArrayList<Member>();
}
```

**연관관계의 주인 - mappedBy는 왜 필요할까?** 

사실 이 이유의 근원은 객체 연관관계와 테이블 연관관계의 차이로부터 찾을 수 있다. 이 둘의 가장 큰 차이는 관계를 정의할 때 테이블 관계는 양방향성을 전제로하고 있고 객체 관계는 단/양 방향 관계에 따라서 필드를 조건부로 추가할 수 있는 구조이다. 따라서 객체 연관관계가 양방향성을 가졌을 때 테이블 연관관계에서 외래 키를 어떤 엔티티를 기준으로 설정하는 지에 따라서 다들 수 있는데,  **mappedBy**를 통해 두 객체 연관관계 중 하나를 정해서 테이블의 외래 키를 관리하는데, 이를 **연관관계의 주인(Owner)이라고 한다.**

양방향 연관관계 매핑 시 지켜야 할 규칙으로, 연관관계의 주인을 정하는 것이 있다. 이는 연관관계 주인만이 데이터베이스 연관관계와 매핑되고 외래 키를 관리할 수 있기 때문이다. 반면, 종속되는 엔티티는 **읽기**만 가능하다. 연관관계의 주인을 식별할 때 **mappedBy**를 사용한다. 

**연관관계 주인은 외래 키가 있는 곳**

연관관계의 주인은 테이블에 외래 키가 있는 곳으로 정해야 한다. 주인이 아닌 엔티티에서 **mappedBy** 속성을 사용해서 **주인이 아님**을 설정한다. 

(참고)

데이터베이스 테이블의 다대일, 일대다 관계에서는 항상 **다** 쪽이 외래 키를 가진다. **다** 쪽인 @ManyToOne은 항상 연관관계의 주인이 되므로 **mappedBy**를 설정할 수 없다. 따라서 @ManyToOne에는 **mappedBy** 속성이 없다. 

____

**양방향 연관관계의 주의점**

*순수한 객체까지 고려한 양방향 연관관계* : 

앞서 언급한 것 처럼 양방향 관계에서 연관관계의 주인만이 데이터베이스에 반영된다. 하지만 주인이 아닌 곳에서도 모두 값을 입력해주는 것이 가장 안전한다. 양쪽 방향 모두 값을 입력하지 않으면 JPA를 사용하지 않는 순수한 객체 상태에서 심각한 문제가 발생할 수 있다. (사실 너무 당연하다.)  양방향 연관관계는 결국 양쪽 모두 신경써야 한다는 것이다. 또한 두 객체의 관계를 재정의하는 과정에서 한 쪽만 관계를 제거하고 나머지를 제거하지 않은 경우 또한 주의해야 한다. 

____

**연관관계 매핑 기초 Summary**

- 단방향 매핑으로 테이블과 객체의 연관관계 매핑은 이미 완료됐다. 
- 단뱡향을 양방향으로 만들면, 반대방향으로 객체 그래프 탐색 기능이 추가된다. (양방향의 장점)
- 양방향 연관관계를 매핑하려면 객체에서 양쪽 방향을 모두 관리해야 한다. (양방향 관계에서 주의)
- 우선 단방향 매핑을 사용하고,반대 방향으로 객체 그래프 탐색 기능이 필요할 때 양방향을 사용하도록 추가하는 방향 
- 양방향 관계의 주인을 정하는 기준 - 외래 키가 있는 곳을 기준 