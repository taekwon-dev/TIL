# [토비의 스프링 3.1 vol1] 6장 AOP (Aspect)

> AOP를 바르게 이용하려면 OOP를 대체하려고 하는 것처럼 보이는 AOP라는 이름 뒤에 감춰진, 그 <u>필연적인 등장배경</u>과 <u>스프링이 그것을 도입한 이유</u>, 그 <u>적용을 통해 얻을 수 있는 장점</u>이 무엇인지에 대한 충분한 이해가 필요하다. 그래야지만 AOP의 가치를 이해하고 효과적으로 사용할 방법을 찾을 수 있다. 또한 까다로운 AOP 학습에 충분한 노력을 투자할 동기도 부여받을 수 있다. 
>
> 스프링에 적용된 가장 인기 있는 AOP의 적용 대상은 바로 선언적 트랜잭션 기능이다. 서비스 추상화를 통해 많은 근본적인 문제를 해결했던 트랜잭션 경계설정 기능을 AOP를 이용해 더욱 세련되고 깔끔한 방식으로 바꿔보자. 그리고 그 과정에서 스프링이 AOP를 도입해야 했던 이유도 알아보자. 

###### - 6.1 트랜잭션 코드의 분리 

###### 	- 6.1.1 메소드 분리

###### 	- 6.1.2 DI(Dependency Injection)를 이용한 클래스의 분리 

###### - 6.2 고립된 단위 테스트 

###### - 6.3 

____

### | 6.1 트랜잭션 코드의 분리 

```java
/** 트랜잭션 경계설정과 비즈니스 로직이 공존하는 메소드 */
public void upgradeLevels() throws Exception {
  
  // 1
  TransactionStatus status = this.transactionManager.getTransaction(new DefaultTransactionDefinition());
  
  // 2
  try {
    List<User> users = userDao.getAll();
    for (User user : users) {
      if (canUpgradeLevel(user)) {
        upgradeLevel(user);
      }
    }
    // 3.1
    this.transactionManager.commit(status);
  } catch (Exception e) {
    // 3.2
    this.transactionManager.rollback(status);
    throw e;
  }
}
```

```java
/** 비즈니스 로직과 트랜잭션 경계설정의 분리 */
public void upgradeLevels() throws Exception {
  // 1
  TransactionStatus status = this.transactionManager.getTransaction(new DefaultTransactionDefinition());
  
  try {
    // 2
		upgradeLevelsInteranl();    
    // 3.1
    this.transactionManager.commit(status);
  } catch (Exception e) {
    // 3.2 
    this.transactionManager.rollback(status);
    throw e;
  }
  
  private void upgradeLevelsInternal() {
        List<User> users = userDao.getAll();
    for (User user : users) {
      if (canUpgradeLevel(user)) {
        upgradeLevel(user);
      }
    }
  }
}
```

메소드를 통해서 비즈니스 로직과 트랜잭션 코드를 분리할 수 있었지만 여전히 동일한 클래스 내부에 공존하고 있다. 위에서 순서를 지정한 것처럼 비즈니스 로직과 트랜잭션 코드 간 실행 순서는 보장해야 하지만 서로 직접적으로 연결되어 있는 상황은 아니다. 여기서 "트랜잭션 코드가 존재하지 않는 것처럼 사라지게 할 수는 없을까?"에 대한 아이디어가 나온다. 여기서 사라지게 한다는 의미는 `userService` 내에서 트랜잭션 코드를 제거함을 의미한다. 

##### | DI 적용을 이용한 트랜잭션 분리

> DI의 기본 아이디어는 실제 사용할 오브젝트 클래스 정체는 감춘 채 인터페이스를 통해 간접으로 접근하는 것이다. 그 덕분에 구현 클래스는 얼마든지 외부에서 변경할 수 있다. 바로 이런 개념을 가진 DI가 지금 필요하다. 

위에서 풀고 싶은 문제인 "트랜잭션 코드가 존재하지 않는 것처럼 사라지게 할 수 없을까?"를 먼저 다루기 전에 <u>DI 적용이 언급된 상황을 먼저 이해하는 것이 앞으로 전개되는 프로세스를 이해하는데 중요한 것 같다</u>. 현재 `UserService` 는 구현 클래스로 존재하고 있다. 따라서 `UserService` 에서 트랜잭션 코드가 제거되면, `UserService` 의 클라이언트는 말 그대로 트랜잭션 코드가 제외된 비즈니스 로직만 사용하게 되는 것이다. 구체적인 구현 클래스에  직접적으로 의존하고 있는 경우에는 트랜잭션 코드를 분리하는 것과 같은 변화를 주는 경우 클라이언트 측 코드까지 모두 수정해야 하는 단점이 있다. 따라서 이러한 직접적인 관계를 느슨하게 만들어주는 DI 개념이 요구된 것이다. 

클라이언트는 구현 클래스에 의존하지 않기 때문에 구현 클래스 내부의 변화 또는 확장에 대해서 매우 유연하게 대처할 수 있다. 트랜잭션 코드를 분리하기 위해 DI 개념을 활용하게 된 배경까지 이해했다면, 이제는 어떤 형태로 트랜잭션 코드를 분리할 수 있는 지 생각해보자.

문제를 해결했을 때의 구조를 생각해보면, 결국 비즈니스 로직이 담긴 코드와 트랜잭션 코드가 분리된 형태로 있고, 서로 협력하는 관계를 가지고 있을 것이다. 클라이언트가 기대하는 결과를 주기 위해서는 비즈니스 코드 + 트랜잭션이 모두 필요하기 때문이다. 따라서 `UserService` 인터페이스를 구현하는 구현 클래스를 각각 만들어서 서로 협력하는 관계로 분리하는 것을 생각해볼 수 있다. 즉, 비즈니스 로직을 담당하는 구현 클래스 외 트랜잭션 책임을 맡고 있는 구현 클래스를 생성하는 것이다. 비즈니스 로직이 분리되어 있으므로, 클라이언트 요청이 들어왔을 때 트랜잭션 구현 클래스에서는 비즈니스 로직 담당하는 구현 클래스에 작업을 위임을 하고, 이 때 트랜잭션 사이에 비즈니스 로직이 포함되도록 (=순서가 보장되도록) 트랜잭션 구현 클래스를 구현하면 된다.

```java
public interface UserService {
  void add(User user);
  void upgradeLevels();
}
```



```java
...
public class UserServiceImpl implements UserService {
  UserDao userDao;
  MailService mailService;
  
  // 트랜잭션 코드가 분리된 비즈니스 로직 코드
  public void upgradeLevels() {
    ...
  }
}  
```



```java
public class UserServiceTx implements UserService {
  // 비즈니스 로직 처리를 위임하기 위한 필드 
  UserService userService;
  
  PlatformTransactionManager transactionManager;
  
 	public void setUserService(UserService userService) {
    this.userService = userService; 
  }
  
 	public void add(User user) {
    // add(User user) -> 위임(Delegate)
    userService.add(user);
  } 
  
  // 트랜잭션 + 비즈니스 로직 
  public void upgradeLevels() {
    
   	// 1
    TransactionStatus status = this.transactionManager.getTransaction(new DefalutTransactionDefinition());

    try {
      // 2
   		userService.upgradeLevels();
      // 3.1
      this.transactionManager.commit(status);
    } catch (RuntimeException e) {
      // 3.2
      this.transactionManager.rollback(status);
      throw e; 
    }
   
    
    
  }
}
```

