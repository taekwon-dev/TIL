# [Spring] 다양한 의존관계 주입 방법과 생성자 주입 권장 이유



DI 프레임워크인 스프링에서 의존관계 주입을 위한 다양한 방법이 있다. DI 프레임워크에서 핵심인 의존관계 주입의 역할을 제대로 수행한다는 전제에서 각각의 상황에 맞는 주입 방법을 아래에서 선택하면 된다. 이일민님의 [토비의 스프링 3.1 Vol 1 - 메소드를 이용한 의존관계 주입] 파트에서 "스프링은 전통적으로 메소들르 이용한 DI 방법 중에서 수정자 메소드를 가장 많이 사용해왔다." 라고 언급했다. 여기서 수정자 메소드는 Java 프로퍼티 규약 중, setter를 의미한다. 이 글을 작성하는 시점에선, 아직 왜 스프링에서 전통적으로 수정자 메소드를 통해 의존관계 주입을 했는 지는 더 확인을 해야겠다. 

우선 이번 글에서는 간략히 스프링의 핵심인 DI를 할 수 있는 다양한 방법에 대해서 정리하고, 그 중 생성자 주입을 권장하는 이유에 대해서 언급할 것이다.

### | 다양한 의존관계 주입 방법 :

- **생성자 주입** 

  생성자 주입은 말 그대로, 스프링 프레임워크에서 해당 클래스를 빈으로 등록할 때 생성자를 통해서 의존관계를 주입하는 방식이다. 생성자가 호출되는 시점에 딱 한 번만 호출되는 것이 보장된다. 

  ```java
  // @Component으로 등록됐고, ComponentScan을 통해서 스프링 (프레임워크)에 의해 빈으로 등록된다. 
  // 이때 최초 한 번 생성자가 호출되면서 의존관계가 주입된다. 
  // ExampleRepository 입장에서, "DI 받는다" 라고 표현할 수도 있다.
  @Component
  public class ExampleServiceImpl implements ExampleService {
    
    private final ExampleRepository exampleRepository; 
    
    @Autowired
    public ExampleServiceImpl(ExampleRepository exampleRepository) {
      	this.exampleRepository = exampleRepository; 
    }
  }
  ```

  이렇게 한 번만 호출되면 어떤 특징이 있을까?  한 번만 호출된다는 것은 생성자가 호출되는 시점 이후에 주입된 의존관계에 대해서 변화가 없음을 의미한다. 또한, 일반적으로 생성자에 포함된 파라미터가 있는 경우 해당 파라미터에 특정 값을 설정해야 한다는 생각을 하게 되는데, 이는 해당 파라미터의 값이 필수적으로 필요함을 내포한다. `final` 을 통해 해당 객체에 두 번 이상 할당할 수 없음을 선언할 수 있고 동시에, 생성자 내부에 값을 설정하지 않은 경우 컴파일 오류를 발생시켜 개발자로 하여금 오류를 쉽게 자각할 수 있도록하는 설계상의 이점이 있다. 

  또한, `@Autowired` 어노테이션은 단어 뜻 그대로 자동적으로 주입할 대상을 찾아서 의존관계 주입을 해주는 역할을 하는데, 생성자 주입을 할 때 생성자가 한 개만 있는 경우에는 `@Autowired` 어노테이션을 생략해도 된다. 단, 엔티티 클래스와 같이 스프링 빈으로 등록되지 않은 경우에는 해당 사항이 없고, 위 예와 같이 스프링 빈으로 등록된 경우에만 해당한다.

- **수정자 주입** (via setter, Java 프로퍼티 규약) 

  수정자 주입은 클래스 내부에 선언된 필드의 값을 수정하는 `setter`를 통해 의존관계를 주입하는 방식이다. 

  ```java
  @Component
  public class ExampleServiceImpl implements ExampleService {
    
    private final ExampleRepository exampleRepository; 
   
    @Autowired
    public void setExampleRepository(ExampleRepository exampleRepository) {
      	this.exampleRepository = exampleRepository; 
    }
    
  }
  ```

  수정자 의존관계 주입 방식은 어떤 특징이 있을까? 단어의 뜻에서도 알 수 있듯이 최초의 상태에서 <u>수정</u>의 맥락이 포함되어 있다. 따라서 생성자 의존관계 주입과 달리 불변의 특징과는 정반대라고 볼 수 있다. 변경 가능성이 있는 의존관계에서 주로 사용된다. 

- **필드 주입**

- **일반 메서드 주입** 

### | 생성자 의존관계 주입을 권장하는 이유 : 

생성자 의존관계 주입 방식을 권장하는 이유는 위에서 언급한 생성자 의존관계 주입의 특징에서 찾을 수 있다. 일반적으로 의존관계 주입이 일어나면, 애플리케이션 종료 시점까지 의존관계를 변경할 일이 많지 않다. 오히려 대부분의 의존관계는 애플리케이션 종료 전 까지 불변해야 한다. 하지만 '반드시' 생성자 주입을 사용해야하는 것이 아닌 만큼 상황에 맞게 유연한 선택 역시 열어놔야 한다. 또 다른 이유로, `setter` 를 통한 의존관계 주입은 설계상 클래스 내 `setter`에 대한 접근 제어자를 `public`으로 열어놔야 한다. 이러한 구조 안에서 발생할 수 있는 여러 문제가 있는데, 우선 변경해선 안되는 상황 속에서 애초에 변경을 하지 못하도록 차단 하는 것이 보다 견고한 설계로 볼 수 있다. 하지만 수정자 의존관계 주입 방법의 경우 항상 변경에 대한 여지가 남아 있으므로 실수에 취약함을 가질 수 있다. 

설계상의 이유도 있지만, 단위 테스트를 진행하는 과정에서도 생성자 의존관계 주입 방식을 선택했을 경우 여러 이점이 있다. 

### | 출처 : 김영한님의 스프링 핵심 원리 - 기본편 강의 내용

